/*
 * Irisnet API
 * Artificial Intelligence (AI) for image- and video-processing in real-time. This is an interactive documentation where you can quickly look up the endpoints and their schemas, while having the opportunity to try things out for yourself.  In the list below, you can see the available endpoints of the API, which can be expanded by clicking on them. Each expanded endpoint lists the request parameters (if available) and the request body (if available). The request body can list some example bodies and the schema, explaining each model in detail.  Additionally you'll find a 'Try it out' button that allows you to enter your custom parameters and custom body and execute that against the API. <b>Be sure to enter your license key to authorize the requests before using this documentation interactively.</b>  The responses section in the expanded endpoint lists the possible responses with their corresponding status codes. If you've executed an API call it will also show you the response from the server.  Underneath the endpoints you'll find the model schemas. These are the models used for the requests and responses. If you click on the right arrow, you can expand the model and get a description of the model and the model parameters. For nested models, you can keep clicking the right arrow for further details.  Clicking the link below the title at the top of this page opens the [OpenAPI specification](https://swagger.io/specification/) (OAS3) in JSON format. The OAS3 Spec allows the generation of clients in many programming languages. There are several free client generators available that can be used to get started easily.
 *
 * The version of the OpenAPI document: v2
 * Contact: info@irisnet.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package de.irisnet.java.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import de.irisnet.java.JSON;

/**
 * Contains information on idDocument sub-checks
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.6.0")
public class IdDocumentSubChecks {
  /**
   * Indicates whether the MRZ checksum is correct
   */
  @JsonAdapter(MrzChecksumEnum.Adapter.class)
  public enum MrzChecksumEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    MrzChecksumEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MrzChecksumEnum fromValue(String value) {
      for (MrzChecksumEnum b : MrzChecksumEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MrzChecksumEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MrzChecksumEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MrzChecksumEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MrzChecksumEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MrzChecksumEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MRZ_CHECKSUM = "mrzChecksum";
  @SerializedName(SERIALIZED_NAME_MRZ_CHECKSUM)
  private MrzChecksumEnum mrzChecksum;

  /**
   * Indicates whether the MRZ format is correct
   */
  @JsonAdapter(MrzFormatEnum.Adapter.class)
  public enum MrzFormatEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    MrzFormatEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MrzFormatEnum fromValue(String value) {
      for (MrzFormatEnum b : MrzFormatEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MrzFormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MrzFormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MrzFormatEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MrzFormatEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MrzFormatEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MRZ_FORMAT = "mrzFormat";
  @SerializedName(SERIALIZED_NAME_MRZ_FORMAT)
  private MrzFormatEnum mrzFormat;

  /**
   * Indicates whether the MRZ is consistent with the document type
   */
  @JsonAdapter(MrzConsistencyEnum.Adapter.class)
  public enum MrzConsistencyEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    MrzConsistencyEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MrzConsistencyEnum fromValue(String value) {
      for (MrzConsistencyEnum b : MrzConsistencyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MrzConsistencyEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MrzConsistencyEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MrzConsistencyEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MrzConsistencyEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      MrzConsistencyEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_MRZ_CONSISTENCY = "mrzConsistency";
  @SerializedName(SERIALIZED_NAME_MRZ_CONSISTENCY)
  private MrzConsistencyEnum mrzConsistency;

  /**
   * Indicates whether the expirationDate is valid
   */
  @JsonAdapter(ExpirationDateEnum.Adapter.class)
  public enum ExpirationDateEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    ExpirationDateEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ExpirationDateEnum fromValue(String value) {
      for (ExpirationDateEnum b : ExpirationDateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ExpirationDateEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ExpirationDateEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ExpirationDateEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ExpirationDateEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ExpirationDateEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_EXPIRATION_DATE = "expirationDate";
  @SerializedName(SERIALIZED_NAME_EXPIRATION_DATE)
  private ExpirationDateEnum expirationDate;

  /**
   * Indicates whether the document&#39;s security elements are valid
   */
  @JsonAdapter(SecurityElementsEnum.Adapter.class)
  public enum SecurityElementsEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    SecurityElementsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SecurityElementsEnum fromValue(String value) {
      for (SecurityElementsEnum b : SecurityElementsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SecurityElementsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SecurityElementsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SecurityElementsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SecurityElementsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SecurityElementsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SECURITY_ELEMENTS = "securityElements";
  @SerializedName(SERIALIZED_NAME_SECURITY_ELEMENTS)
  private SecurityElementsEnum securityElements;

  /**
   * Indicates whether the photo is in the correct location for a given document type
   */
  @JsonAdapter(PhotoLocationEnum.Adapter.class)
  public enum PhotoLocationEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    PhotoLocationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PhotoLocationEnum fromValue(String value) {
      for (PhotoLocationEnum b : PhotoLocationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PhotoLocationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PhotoLocationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PhotoLocationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PhotoLocationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PhotoLocationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PHOTO_LOCATION = "photoLocation";
  @SerializedName(SERIALIZED_NAME_PHOTO_LOCATION)
  private PhotoLocationEnum photoLocation;

  /**
   * Indicates whether a competent authority deny-listed the ID document
   */
  @JsonAdapter(BlacklistCheckEnum.Adapter.class)
  public enum BlacklistCheckEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    BlacklistCheckEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static BlacklistCheckEnum fromValue(String value) {
      for (BlacklistCheckEnum b : BlacklistCheckEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<BlacklistCheckEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final BlacklistCheckEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public BlacklistCheckEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return BlacklistCheckEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      BlacklistCheckEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_BLACKLIST_CHECK = "blacklistCheck";
  @SerializedName(SERIALIZED_NAME_BLACKLIST_CHECK)
  private BlacklistCheckEnum blacklistCheck;

  /**
   * Indicates whether the document is a photocopy
   */
  @JsonAdapter(PhotocopyCheckEnum.Adapter.class)
  public enum PhotocopyCheckEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    PhotocopyCheckEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PhotocopyCheckEnum fromValue(String value) {
      for (PhotocopyCheckEnum b : PhotocopyCheckEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PhotocopyCheckEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PhotocopyCheckEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PhotocopyCheckEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PhotocopyCheckEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PhotocopyCheckEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PHOTOCOPY_CHECK = "photocopyCheck";
  @SerializedName(SERIALIZED_NAME_PHOTOCOPY_CHECK)
  private PhotocopyCheckEnum photocopyCheck;

  /**
   * Indicates whether the document has been copied from the Internet
   */
  @JsonAdapter(SpecimenCheckEnum.Adapter.class)
  public enum SpecimenCheckEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    SpecimenCheckEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SpecimenCheckEnum fromValue(String value) {
      for (SpecimenCheckEnum b : SpecimenCheckEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SpecimenCheckEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SpecimenCheckEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SpecimenCheckEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SpecimenCheckEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SpecimenCheckEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SPECIMEN_CHECK = "specimenCheck";
  @SerializedName(SERIALIZED_NAME_SPECIMEN_CHECK)
  private SpecimenCheckEnum specimenCheck;

  /**
   * Indicates whether the document model has been identified
   */
  @JsonAdapter(DocumentModelIdentificationEnum.Adapter.class)
  public enum DocumentModelIdentificationEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    DocumentModelIdentificationEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DocumentModelIdentificationEnum fromValue(String value) {
      for (DocumentModelIdentificationEnum b : DocumentModelIdentificationEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DocumentModelIdentificationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DocumentModelIdentificationEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DocumentModelIdentificationEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DocumentModelIdentificationEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DocumentModelIdentificationEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DOCUMENT_MODEL_IDENTIFICATION = "documentModelIdentification";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_MODEL_IDENTIFICATION)
  private DocumentModelIdentificationEnum documentModelIdentification;

  /**
   * Indicates if the document image is genuine and not a photo of an image or of a screen
   */
  @JsonAdapter(DocumentLivenessCheckEnum.Adapter.class)
  public enum DocumentLivenessCheckEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    DocumentLivenessCheckEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DocumentLivenessCheckEnum fromValue(String value) {
      for (DocumentLivenessCheckEnum b : DocumentLivenessCheckEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DocumentLivenessCheckEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DocumentLivenessCheckEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DocumentLivenessCheckEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DocumentLivenessCheckEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DocumentLivenessCheckEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DOCUMENT_LIVENESS_CHECK = "documentLivenessCheck";
  @SerializedName(SERIALIZED_NAME_DOCUMENT_LIVENESS_CHECK)
  private DocumentLivenessCheckEnum documentLivenessCheck;

  /**
   * Indicates whether the selfie image is spoofed, copied from the Internet, or is a known deny-listed image
   */
  @JsonAdapter(SpoofedImageAnalysisEnum.Adapter.class)
  public enum SpoofedImageAnalysisEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    SpoofedImageAnalysisEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SpoofedImageAnalysisEnum fromValue(String value) {
      for (SpoofedImageAnalysisEnum b : SpoofedImageAnalysisEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SpoofedImageAnalysisEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SpoofedImageAnalysisEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SpoofedImageAnalysisEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SpoofedImageAnalysisEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SpoofedImageAnalysisEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SPOOFED_IMAGE_ANALYSIS = "spoofedImageAnalysis";
  @SerializedName(SERIALIZED_NAME_SPOOFED_IMAGE_ANALYSIS)
  private SpoofedImageAnalysisEnum spoofedImageAnalysis;

  /**
   * Indicates if the selfie image is genuine and not a photo of an image or of a screen
   */
  @JsonAdapter(FaceLivenessCheckEnum.Adapter.class)
  public enum FaceLivenessCheckEnum {
    PASSED("passed"),
    
    FAILED("failed"),
    
    NOT_PROCESSED("not_processed");

    private String value;

    FaceLivenessCheckEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FaceLivenessCheckEnum fromValue(String value) {
      for (FaceLivenessCheckEnum b : FaceLivenessCheckEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FaceLivenessCheckEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FaceLivenessCheckEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FaceLivenessCheckEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FaceLivenessCheckEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FaceLivenessCheckEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FACE_LIVENESS_CHECK = "faceLivenessCheck";
  @SerializedName(SERIALIZED_NAME_FACE_LIVENESS_CHECK)
  private FaceLivenessCheckEnum faceLivenessCheck;

  public IdDocumentSubChecks() {
  }

  public IdDocumentSubChecks mrzChecksum(MrzChecksumEnum mrzChecksum) {
    this.mrzChecksum = mrzChecksum;
    return this;
  }

   /**
   * Indicates whether the MRZ checksum is correct
   * @return mrzChecksum
  **/
  @javax.annotation.Nullable
  public MrzChecksumEnum getMrzChecksum() {
    return mrzChecksum;
  }

  public void setMrzChecksum(MrzChecksumEnum mrzChecksum) {
    this.mrzChecksum = mrzChecksum;
  }


  public IdDocumentSubChecks mrzFormat(MrzFormatEnum mrzFormat) {
    this.mrzFormat = mrzFormat;
    return this;
  }

   /**
   * Indicates whether the MRZ format is correct
   * @return mrzFormat
  **/
  @javax.annotation.Nullable
  public MrzFormatEnum getMrzFormat() {
    return mrzFormat;
  }

  public void setMrzFormat(MrzFormatEnum mrzFormat) {
    this.mrzFormat = mrzFormat;
  }


  public IdDocumentSubChecks mrzConsistency(MrzConsistencyEnum mrzConsistency) {
    this.mrzConsistency = mrzConsistency;
    return this;
  }

   /**
   * Indicates whether the MRZ is consistent with the document type
   * @return mrzConsistency
  **/
  @javax.annotation.Nullable
  public MrzConsistencyEnum getMrzConsistency() {
    return mrzConsistency;
  }

  public void setMrzConsistency(MrzConsistencyEnum mrzConsistency) {
    this.mrzConsistency = mrzConsistency;
  }


  public IdDocumentSubChecks expirationDate(ExpirationDateEnum expirationDate) {
    this.expirationDate = expirationDate;
    return this;
  }

   /**
   * Indicates whether the expirationDate is valid
   * @return expirationDate
  **/
  @javax.annotation.Nullable
  public ExpirationDateEnum getExpirationDate() {
    return expirationDate;
  }

  public void setExpirationDate(ExpirationDateEnum expirationDate) {
    this.expirationDate = expirationDate;
  }


  public IdDocumentSubChecks securityElements(SecurityElementsEnum securityElements) {
    this.securityElements = securityElements;
    return this;
  }

   /**
   * Indicates whether the document&#39;s security elements are valid
   * @return securityElements
  **/
  @javax.annotation.Nullable
  public SecurityElementsEnum getSecurityElements() {
    return securityElements;
  }

  public void setSecurityElements(SecurityElementsEnum securityElements) {
    this.securityElements = securityElements;
  }


  public IdDocumentSubChecks photoLocation(PhotoLocationEnum photoLocation) {
    this.photoLocation = photoLocation;
    return this;
  }

   /**
   * Indicates whether the photo is in the correct location for a given document type
   * @return photoLocation
  **/
  @javax.annotation.Nullable
  public PhotoLocationEnum getPhotoLocation() {
    return photoLocation;
  }

  public void setPhotoLocation(PhotoLocationEnum photoLocation) {
    this.photoLocation = photoLocation;
  }


  public IdDocumentSubChecks blacklistCheck(BlacklistCheckEnum blacklistCheck) {
    this.blacklistCheck = blacklistCheck;
    return this;
  }

   /**
   * Indicates whether a competent authority deny-listed the ID document
   * @return blacklistCheck
  **/
  @javax.annotation.Nullable
  public BlacklistCheckEnum getBlacklistCheck() {
    return blacklistCheck;
  }

  public void setBlacklistCheck(BlacklistCheckEnum blacklistCheck) {
    this.blacklistCheck = blacklistCheck;
  }


  public IdDocumentSubChecks photocopyCheck(PhotocopyCheckEnum photocopyCheck) {
    this.photocopyCheck = photocopyCheck;
    return this;
  }

   /**
   * Indicates whether the document is a photocopy
   * @return photocopyCheck
  **/
  @javax.annotation.Nullable
  public PhotocopyCheckEnum getPhotocopyCheck() {
    return photocopyCheck;
  }

  public void setPhotocopyCheck(PhotocopyCheckEnum photocopyCheck) {
    this.photocopyCheck = photocopyCheck;
  }


  public IdDocumentSubChecks specimenCheck(SpecimenCheckEnum specimenCheck) {
    this.specimenCheck = specimenCheck;
    return this;
  }

   /**
   * Indicates whether the document has been copied from the Internet
   * @return specimenCheck
  **/
  @javax.annotation.Nullable
  public SpecimenCheckEnum getSpecimenCheck() {
    return specimenCheck;
  }

  public void setSpecimenCheck(SpecimenCheckEnum specimenCheck) {
    this.specimenCheck = specimenCheck;
  }


  public IdDocumentSubChecks documentModelIdentification(DocumentModelIdentificationEnum documentModelIdentification) {
    this.documentModelIdentification = documentModelIdentification;
    return this;
  }

   /**
   * Indicates whether the document model has been identified
   * @return documentModelIdentification
  **/
  @javax.annotation.Nullable
  public DocumentModelIdentificationEnum getDocumentModelIdentification() {
    return documentModelIdentification;
  }

  public void setDocumentModelIdentification(DocumentModelIdentificationEnum documentModelIdentification) {
    this.documentModelIdentification = documentModelIdentification;
  }


  public IdDocumentSubChecks documentLivenessCheck(DocumentLivenessCheckEnum documentLivenessCheck) {
    this.documentLivenessCheck = documentLivenessCheck;
    return this;
  }

   /**
   * Indicates if the document image is genuine and not a photo of an image or of a screen
   * @return documentLivenessCheck
  **/
  @javax.annotation.Nullable
  public DocumentLivenessCheckEnum getDocumentLivenessCheck() {
    return documentLivenessCheck;
  }

  public void setDocumentLivenessCheck(DocumentLivenessCheckEnum documentLivenessCheck) {
    this.documentLivenessCheck = documentLivenessCheck;
  }


  public IdDocumentSubChecks spoofedImageAnalysis(SpoofedImageAnalysisEnum spoofedImageAnalysis) {
    this.spoofedImageAnalysis = spoofedImageAnalysis;
    return this;
  }

   /**
   * Indicates whether the selfie image is spoofed, copied from the Internet, or is a known deny-listed image
   * @return spoofedImageAnalysis
  **/
  @javax.annotation.Nullable
  public SpoofedImageAnalysisEnum getSpoofedImageAnalysis() {
    return spoofedImageAnalysis;
  }

  public void setSpoofedImageAnalysis(SpoofedImageAnalysisEnum spoofedImageAnalysis) {
    this.spoofedImageAnalysis = spoofedImageAnalysis;
  }


  public IdDocumentSubChecks faceLivenessCheck(FaceLivenessCheckEnum faceLivenessCheck) {
    this.faceLivenessCheck = faceLivenessCheck;
    return this;
  }

   /**
   * Indicates if the selfie image is genuine and not a photo of an image or of a screen
   * @return faceLivenessCheck
  **/
  @javax.annotation.Nullable
  public FaceLivenessCheckEnum getFaceLivenessCheck() {
    return faceLivenessCheck;
  }

  public void setFaceLivenessCheck(FaceLivenessCheckEnum faceLivenessCheck) {
    this.faceLivenessCheck = faceLivenessCheck;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    IdDocumentSubChecks idDocumentSubChecks = (IdDocumentSubChecks) o;
    return Objects.equals(this.mrzChecksum, idDocumentSubChecks.mrzChecksum) &&
        Objects.equals(this.mrzFormat, idDocumentSubChecks.mrzFormat) &&
        Objects.equals(this.mrzConsistency, idDocumentSubChecks.mrzConsistency) &&
        Objects.equals(this.expirationDate, idDocumentSubChecks.expirationDate) &&
        Objects.equals(this.securityElements, idDocumentSubChecks.securityElements) &&
        Objects.equals(this.photoLocation, idDocumentSubChecks.photoLocation) &&
        Objects.equals(this.blacklistCheck, idDocumentSubChecks.blacklistCheck) &&
        Objects.equals(this.photocopyCheck, idDocumentSubChecks.photocopyCheck) &&
        Objects.equals(this.specimenCheck, idDocumentSubChecks.specimenCheck) &&
        Objects.equals(this.documentModelIdentification, idDocumentSubChecks.documentModelIdentification) &&
        Objects.equals(this.documentLivenessCheck, idDocumentSubChecks.documentLivenessCheck) &&
        Objects.equals(this.spoofedImageAnalysis, idDocumentSubChecks.spoofedImageAnalysis) &&
        Objects.equals(this.faceLivenessCheck, idDocumentSubChecks.faceLivenessCheck);
  }

  @Override
  public int hashCode() {
    return Objects.hash(mrzChecksum, mrzFormat, mrzConsistency, expirationDate, securityElements, photoLocation, blacklistCheck, photocopyCheck, specimenCheck, documentModelIdentification, documentLivenessCheck, spoofedImageAnalysis, faceLivenessCheck);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class IdDocumentSubChecks {\n");
    sb.append("    mrzChecksum: ").append(toIndentedString(mrzChecksum)).append("\n");
    sb.append("    mrzFormat: ").append(toIndentedString(mrzFormat)).append("\n");
    sb.append("    mrzConsistency: ").append(toIndentedString(mrzConsistency)).append("\n");
    sb.append("    expirationDate: ").append(toIndentedString(expirationDate)).append("\n");
    sb.append("    securityElements: ").append(toIndentedString(securityElements)).append("\n");
    sb.append("    photoLocation: ").append(toIndentedString(photoLocation)).append("\n");
    sb.append("    blacklistCheck: ").append(toIndentedString(blacklistCheck)).append("\n");
    sb.append("    photocopyCheck: ").append(toIndentedString(photocopyCheck)).append("\n");
    sb.append("    specimenCheck: ").append(toIndentedString(specimenCheck)).append("\n");
    sb.append("    documentModelIdentification: ").append(toIndentedString(documentModelIdentification)).append("\n");
    sb.append("    documentLivenessCheck: ").append(toIndentedString(documentLivenessCheck)).append("\n");
    sb.append("    spoofedImageAnalysis: ").append(toIndentedString(spoofedImageAnalysis)).append("\n");
    sb.append("    faceLivenessCheck: ").append(toIndentedString(faceLivenessCheck)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("mrzChecksum");
    openapiFields.add("mrzFormat");
    openapiFields.add("mrzConsistency");
    openapiFields.add("expirationDate");
    openapiFields.add("securityElements");
    openapiFields.add("photoLocation");
    openapiFields.add("blacklistCheck");
    openapiFields.add("photocopyCheck");
    openapiFields.add("specimenCheck");
    openapiFields.add("documentModelIdentification");
    openapiFields.add("documentLivenessCheck");
    openapiFields.add("spoofedImageAnalysis");
    openapiFields.add("faceLivenessCheck");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Element and throws an exception if issues found
  *
  * @param jsonElement JSON Element
  * @throws IOException if the JSON Element is invalid with respect to IdDocumentSubChecks
  */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!IdDocumentSubChecks.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in IdDocumentSubChecks is not found in the empty JSON string", IdDocumentSubChecks.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!IdDocumentSubChecks.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `IdDocumentSubChecks` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("mrzChecksum") != null && !jsonObj.get("mrzChecksum").isJsonNull()) && !jsonObj.get("mrzChecksum").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mrzChecksum` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mrzChecksum").toString()));
      }
      // validate the optional field `mrzChecksum`
      if (jsonObj.get("mrzChecksum") != null && !jsonObj.get("mrzChecksum").isJsonNull()) {
        MrzChecksumEnum.validateJsonElement(jsonObj.get("mrzChecksum"));
      }
      if ((jsonObj.get("mrzFormat") != null && !jsonObj.get("mrzFormat").isJsonNull()) && !jsonObj.get("mrzFormat").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mrzFormat` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mrzFormat").toString()));
      }
      // validate the optional field `mrzFormat`
      if (jsonObj.get("mrzFormat") != null && !jsonObj.get("mrzFormat").isJsonNull()) {
        MrzFormatEnum.validateJsonElement(jsonObj.get("mrzFormat"));
      }
      if ((jsonObj.get("mrzConsistency") != null && !jsonObj.get("mrzConsistency").isJsonNull()) && !jsonObj.get("mrzConsistency").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `mrzConsistency` to be a primitive type in the JSON string but got `%s`", jsonObj.get("mrzConsistency").toString()));
      }
      // validate the optional field `mrzConsistency`
      if (jsonObj.get("mrzConsistency") != null && !jsonObj.get("mrzConsistency").isJsonNull()) {
        MrzConsistencyEnum.validateJsonElement(jsonObj.get("mrzConsistency"));
      }
      if ((jsonObj.get("expirationDate") != null && !jsonObj.get("expirationDate").isJsonNull()) && !jsonObj.get("expirationDate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `expirationDate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("expirationDate").toString()));
      }
      // validate the optional field `expirationDate`
      if (jsonObj.get("expirationDate") != null && !jsonObj.get("expirationDate").isJsonNull()) {
        ExpirationDateEnum.validateJsonElement(jsonObj.get("expirationDate"));
      }
      if ((jsonObj.get("securityElements") != null && !jsonObj.get("securityElements").isJsonNull()) && !jsonObj.get("securityElements").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `securityElements` to be a primitive type in the JSON string but got `%s`", jsonObj.get("securityElements").toString()));
      }
      // validate the optional field `securityElements`
      if (jsonObj.get("securityElements") != null && !jsonObj.get("securityElements").isJsonNull()) {
        SecurityElementsEnum.validateJsonElement(jsonObj.get("securityElements"));
      }
      if ((jsonObj.get("photoLocation") != null && !jsonObj.get("photoLocation").isJsonNull()) && !jsonObj.get("photoLocation").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `photoLocation` to be a primitive type in the JSON string but got `%s`", jsonObj.get("photoLocation").toString()));
      }
      // validate the optional field `photoLocation`
      if (jsonObj.get("photoLocation") != null && !jsonObj.get("photoLocation").isJsonNull()) {
        PhotoLocationEnum.validateJsonElement(jsonObj.get("photoLocation"));
      }
      if ((jsonObj.get("blacklistCheck") != null && !jsonObj.get("blacklistCheck").isJsonNull()) && !jsonObj.get("blacklistCheck").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `blacklistCheck` to be a primitive type in the JSON string but got `%s`", jsonObj.get("blacklistCheck").toString()));
      }
      // validate the optional field `blacklistCheck`
      if (jsonObj.get("blacklistCheck") != null && !jsonObj.get("blacklistCheck").isJsonNull()) {
        BlacklistCheckEnum.validateJsonElement(jsonObj.get("blacklistCheck"));
      }
      if ((jsonObj.get("photocopyCheck") != null && !jsonObj.get("photocopyCheck").isJsonNull()) && !jsonObj.get("photocopyCheck").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `photocopyCheck` to be a primitive type in the JSON string but got `%s`", jsonObj.get("photocopyCheck").toString()));
      }
      // validate the optional field `photocopyCheck`
      if (jsonObj.get("photocopyCheck") != null && !jsonObj.get("photocopyCheck").isJsonNull()) {
        PhotocopyCheckEnum.validateJsonElement(jsonObj.get("photocopyCheck"));
      }
      if ((jsonObj.get("specimenCheck") != null && !jsonObj.get("specimenCheck").isJsonNull()) && !jsonObj.get("specimenCheck").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `specimenCheck` to be a primitive type in the JSON string but got `%s`", jsonObj.get("specimenCheck").toString()));
      }
      // validate the optional field `specimenCheck`
      if (jsonObj.get("specimenCheck") != null && !jsonObj.get("specimenCheck").isJsonNull()) {
        SpecimenCheckEnum.validateJsonElement(jsonObj.get("specimenCheck"));
      }
      if ((jsonObj.get("documentModelIdentification") != null && !jsonObj.get("documentModelIdentification").isJsonNull()) && !jsonObj.get("documentModelIdentification").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentModelIdentification` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentModelIdentification").toString()));
      }
      // validate the optional field `documentModelIdentification`
      if (jsonObj.get("documentModelIdentification") != null && !jsonObj.get("documentModelIdentification").isJsonNull()) {
        DocumentModelIdentificationEnum.validateJsonElement(jsonObj.get("documentModelIdentification"));
      }
      if ((jsonObj.get("documentLivenessCheck") != null && !jsonObj.get("documentLivenessCheck").isJsonNull()) && !jsonObj.get("documentLivenessCheck").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `documentLivenessCheck` to be a primitive type in the JSON string but got `%s`", jsonObj.get("documentLivenessCheck").toString()));
      }
      // validate the optional field `documentLivenessCheck`
      if (jsonObj.get("documentLivenessCheck") != null && !jsonObj.get("documentLivenessCheck").isJsonNull()) {
        DocumentLivenessCheckEnum.validateJsonElement(jsonObj.get("documentLivenessCheck"));
      }
      if ((jsonObj.get("spoofedImageAnalysis") != null && !jsonObj.get("spoofedImageAnalysis").isJsonNull()) && !jsonObj.get("spoofedImageAnalysis").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `spoofedImageAnalysis` to be a primitive type in the JSON string but got `%s`", jsonObj.get("spoofedImageAnalysis").toString()));
      }
      // validate the optional field `spoofedImageAnalysis`
      if (jsonObj.get("spoofedImageAnalysis") != null && !jsonObj.get("spoofedImageAnalysis").isJsonNull()) {
        SpoofedImageAnalysisEnum.validateJsonElement(jsonObj.get("spoofedImageAnalysis"));
      }
      if ((jsonObj.get("faceLivenessCheck") != null && !jsonObj.get("faceLivenessCheck").isJsonNull()) && !jsonObj.get("faceLivenessCheck").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `faceLivenessCheck` to be a primitive type in the JSON string but got `%s`", jsonObj.get("faceLivenessCheck").toString()));
      }
      // validate the optional field `faceLivenessCheck`
      if (jsonObj.get("faceLivenessCheck") != null && !jsonObj.get("faceLivenessCheck").isJsonNull()) {
        FaceLivenessCheckEnum.validateJsonElement(jsonObj.get("faceLivenessCheck"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!IdDocumentSubChecks.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'IdDocumentSubChecks' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<IdDocumentSubChecks> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(IdDocumentSubChecks.class));

       return (TypeAdapter<T>) new TypeAdapter<IdDocumentSubChecks>() {
           @Override
           public void write(JsonWriter out, IdDocumentSubChecks value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public IdDocumentSubChecks read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of IdDocumentSubChecks given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of IdDocumentSubChecks
  * @throws IOException if the JSON string is invalid with respect to IdDocumentSubChecks
  */
  public static IdDocumentSubChecks fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, IdDocumentSubChecks.class);
  }

 /**
  * Convert an instance of IdDocumentSubChecks to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

